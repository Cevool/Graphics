#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/PostProcessing/Shaders/PostProcessDefines.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/PostProcessing/Shaders/DepthOfFieldCommon.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingSampling.hlsl"

#pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch

#pragma multi_compile _ FAST_APPROXIMAION

#pragma kernel KMain

#pragma multi_compile _ ENABLE_ALPHA

CBUFFER_START(cb0)
float4 _Params;
float4 _Params2;
CBUFFER_END

#define NumRings            _Params.x
#define MaxCoCRadius        _Params.y
#define Anamorphism         _Params.z
#define MaxCoCMipLevel      _Params2.x
#define MaxColorMip         _Params2.w

// Input textures
TEXTURE2D_X(_InputTexture);
TEXTURE2D_X(_InputCoCTexture);
TEXTURE2D_X(_TileList);

// Outpute texture
RW_TEXTURE2D_X(CTYPE, _OutputTexture);

#define TILE_RES  8u

// A set of Defines to fine-tune the algorithm
#define ADAPTIVE_SAMPLING
#define STRATIFY
#define FORCE_POINT_SAMPLING
#define RING_OCCLUSION
#ifndef FAST_APPROXIMAION
    #define PHYSICAL_WEIGHTS
#endif

#define GROUP_RES  8u
#define GROUP_SIZE (GROUP_RES * GROUP_RES)

struct AccumData
{
    float4 color;
    float alpha;
    float coverage;
    float CoC;
    float maxCoC;
};

struct SampleData
{
    CTYPE color;
    float CoC;
};

float GetCoCRadius(int2 positionSS)
{
    float CoCRadius = LOAD_TEXTURE2D_X(_InputCoCTexture, positionSS).x;
    return CoCRadius;
}

CTYPE GetColorSample(float2 sampleTC, float lod)
{
#ifndef FORCE_POINT_SAMPLING
    return SAMPLE_TEXTURE2D_X_LOD(_InputTexture, s_trilinear_clamp_sampler, ClampAndScaleUVForBilinear(sampleTC * _ScreenSize.zw), lod).CTYPE_SWIZZLE;
#else
    return LOAD_TEXTURE2D_X(_InputTexture, sampleTC).CTYPE_SWIZZLE;
#endif
}

float GetSampleWeight(float cocRadius)
{
#ifdef PHYSICAL_WEIGHTS
    float pixelRadius = 0.7071f;
    float radius = max(pixelRadius, abs(cocRadius));
    return PI * pixelRadius * pixelRadius * rcp(PI * radius * radius);
#else
    return 1.0f;
#endif
}

float2 PointInCircle(float angle)
{
    return float2(cos(angle), sin(angle)) * float2 (1 - Anamorphism, 1 + Anamorphism);
}

void ResolveColorAndAlpha(inout float4 outColor, inout float outAlpha, CTYPE defaultValue)
{
    outColor.xyz = outColor.w > 0 ? outColor.xyz / outColor.w : defaultValue.xyz;
#ifdef ENABLE_ALPHA
    outAlpha = outColor.w > 0 ? outAlpha / outColor.w : defaultValue.w;
#endif
}

#ifdef FAST_APPROXIMAION

void AccumulateSample(SampleData sampleData, float centerCoC, float2 limit, inout float4 colorAccum, inout float alphaAccum)
{
    float dw = 1;
    if (sampleData.CoC >= 0 && abs(centerCoC) < limit.y)
    {
        // occlusion test: if the central CoC occludes the sample that we gather, then the sample weight should be zero
        dw = (sampleData.CoC <= limit.x * centerCoC) ? 1.0 : 0.0;
    }

    float weight = dw * GetSampleWeight(abs(sampleData.CoC));
    colorAccum += float4(sampleData.color.xyz * weight, weight);
#ifdef ENABLE_ALPHA
    alphaAccum += sampleData.color.w * weight;
#endif
}

void DoFGatherFast(PositionInputs posInputs, int numSamples, float maxRadius, SampleData centerSample, out float4 outColor, out float outAlpha)
{
    AccumData accumData;
    ZERO_INITIALIZE(AccumData, accumData);

    float dR = rcp(numSamples);
    int blueNoiseOffset = _TaaFrameInfo.w != 0.0 ? _TaaFrameInfo.z : 0;
    numSamples = maxRadius > 0 ? numSamples : 0;
    int halfSamples = numSamples >> 1;
    float dAng = PI * rcp(halfSamples);

    // Select the appropriate mip to sample based on the amount of samples. Lower sample counts will be faster at the cost of "leaking"
    float lod = min(MaxColorMip, log2(2 * PI * maxRadius * rcp(numSamples)));

    // Gather the DoF samples
    for (int ring = 0; ring < numSamples; ring += 1)
    {
        for (int i = 0; i < halfSamples; i += 1)
        {
            SampleData sampleData[2];
            const float offset[2] = { 0, PI };

            float r1 = GetBNDSequenceSample(posInputs.positionSS.xy, ring * numSamples + i + blueNoiseOffset, 1);
            float r2 = GetBNDSequenceSample(posInputs.positionSS.xy, ring * numSamples + i + blueNoiseOffset, 0);

#ifdef STRATIFY
            float sampleRadius = sqrt((ring + r2) * dR) * maxRadius;
#else
            float sampleRadius = sqrt(r2) * maxRadius;
#endif
            UNITY_UNROLL
            for (int j = 0; j < 2; j++)
            {
#ifdef STRATIFY
                float2 sampleTC = posInputs.positionSS + sampleRadius * PointInCircle(offset[j] + (i + r1) * dAng);
#else
                float2 sampleTC = posInputs.positionSS + sampleRadius * PointInCircle(offset[j] + r1 * PI);
#endif
                sampleData[j].color = GetColorSample(sampleTC, lod);
                sampleData[j].CoC = GetCoCRadius(sampleTC);
            }

            const float occlusionTestRange = 9;
            float bias = 1.0 + r1;
            float2 limit = float2(bias, occlusionTestRange * bias);

            UNITY_UNROLL
            for (int k = 0; k < 2; k++)
            {
                if (abs(sampleData[k].CoC) >= sampleRadius)
                {
                    AccumulateSample(sampleData[k], centerSample.CoC, limit, accumData.color, accumData.alpha);
                }
                else
                {
                    int pairIndex = (k == 0)? 1 : 0;
                    if (abs(sampleData[pairIndex].CoC) >= sampleRadius)
                    {
                        AccumulateSample(sampleData[pairIndex], centerSample.CoC, limit, accumData.color, accumData.alpha);
                    }
                    else
                    {
                        float norm = max(accumData.color.w, REAL_MIN); // to avoid div-by-zero warning
                        float3 backgroundEstimator = accumData.color.w > 0 ? accumData.color.xyz * rcp(norm) : centerSample.color.xyz;
#ifdef ENABLE_ALPHA
                        float alphaEstimator = accumData.color.w > 0 ? accumData.alpha * rcp(norm) : centerSample.color.w;
                        accumData.alpha += alphaEstimator;
#endif
                        accumData.color += float4(backgroundEstimator, 1.0);
                    }
                }
            }
        }
    }

    outColor = accumData.color;
    outAlpha = accumData.alpha;

    ResolveColorAndAlpha(outColor, outAlpha, centerSample.color);
}

#else

void AccumulateSample(SampleData sampleData, float weight, inout AccumData accumData)
{
    accumData.color += float4(sampleData.color.xyz * weight, weight);
    accumData.CoC += abs(sampleData.CoC) * weight;
#ifdef ENABLE_ALPHA
    accumData.alpha += sampleData.color.w * weight;
#endif
    if (weight > 0)
    {
        accumData.maxCoC = max(accumData.maxCoC, abs(sampleData.CoC));
    }
}

void AccumulateCenterSample(SampleData centerSample, inout AccumData accumData)
{
    float centerAlpha = GetSampleWeight(centerSample.CoC);
    //AccumulateSample(centerSample, centerAlpha, accumData.color, accumData.CoC, accumData.maxCoC, accumData.alpha);

    accumData.color.xyz = accumData.color.xyz * (1 - centerAlpha) + centerAlpha * centerSample.color.xyz;
    accumData.color.w = accumData.color.w * (1 - centerAlpha) + centerAlpha;
#ifdef ENABLE_ALPHA
    accumData.alpha = accumData.alpha * (1 - centerAlpha) + centerAlpha * centerSample.color.w;
#endif
    accumData.maxCoC = max(accumData.maxCoC, centerSample.CoC);

}

void AccumulateSampleData(SampleData sampleData[2], SampleData centerSample, float sampleRadius, float borderRadius, const bool isForeground, inout AccumData ringAccum, inout AccumData accumData)
{
    UNITY_UNROLL
        for (int k = 0; k < 2; k++)
        {
            float CoC = isForeground ? -sampleData[k].CoC : sampleData[k].CoC;

            float sampleWeight = GetSampleWeight(CoC);
            //float visibility = saturate(CoC - sampleRadius);
            float visibility = step(0.0, CoC - sampleRadius);

            // Check if the sample belongs to the current bucket
            float borderWeight = saturate(CoC - borderRadius);

#ifndef RING_OCCLUSION
            borderWeight = 0;
#endif

            if (isForeground)
            {
                AccumulateSample(sampleData[k], visibility * sampleWeight, ringAccum);
                ringAccum.coverage += visibility;
            }
            else
            {
                AccumulateSample(sampleData[k], borderWeight * visibility * sampleWeight, accumData);
                AccumulateSample(sampleData[k], (1.0 - borderWeight) * visibility * sampleWeight, ringAccum);
                ringAccum.coverage += borderWeight;
            }

#if 0
            // Disabled for now due to artifacts
            // Mirroring improves the near blur, but since the background reconstruction is not perfect, we limit the radius it is applied
            const float mirrorLimit = 2;
            const float radius = sampleRadius - CoC;
            if (ringData.isForeground && visibility == 0 && radius < mirrorLimit)
            {
                int pairIndex = k == 0 ? 1 : 0;
                float mirrorWeight = 1 ;
                //AccumulateSample(sampleData[pairIndex], mirrorWeight * sampleWeight, ringAccum);
            }
#endif
        }
}

void AccumulateRingData(float numSamples, const bool isForeground, AccumData ringData, inout AccumData accumData)
{
    if (ringData.color.w == 0)
    {
        // nothing to accumulate
        return;
    }

    float ringAvgCoC = ringData.color.w > 0 ? ringData.CoC * rcp(ringData.color.w) : 0;
    float accumAvgCoC = accumData.color.w > 0 ? accumData.CoC * rcp(accumData.color.w) : 0;

    float ringOcclusion = saturate(accumAvgCoC - ringAvgCoC);
    float ringOpacity = 1.0 - saturate(ringData.coverage * rcp(numSamples));

    if (isForeground)
    {
        accumData.color += ringData.color;
        accumData.alpha += ringData.alpha;
        accumData.CoC += ringData.CoC;
        accumData.coverage += ringData.coverage;
        accumData.maxCoC = max(accumData.maxCoC, ringData.maxCoC);
    }
    else
    {
        // back-to-front blending
        float alpha = 0.0;
#ifdef  RING_OCCLUSION
        alpha = (accumData.color.w > 0.0) ? ringOpacity * ringOcclusion : 1.0;
#endif
        accumData.color = accumData.color * (1.0 - alpha) + ringData.color;
        accumData.alpha = accumData.alpha * (1.0 - alpha) + ringData.alpha;
        accumData.CoC = accumData.CoC * (1.0 - alpha) + ringData.CoC;
        //accumData.coverage = accumData.coverage * (1.0 - alpha) + ringData.coverage;
    }
}

void DoFGatherRings(PositionInputs posInputs, int numSamples, float maxRadius, SampleData centerSample, out float4 color, out float alpha)
{
    AccumData bgAccumData, fgAccumData;
    ZERO_INITIALIZE(AccumData, bgAccumData);
    ZERO_INITIALIZE(AccumData, fgAccumData);

    float dR = rcp(numSamples);
    int blueNoiseOffset = _TaaFrameInfo.w != 0.0 ? _TaaFrameInfo.z : 0;
    numSamples = maxRadius > 0 ? numSamples : 0;
    int halfSamples = numSamples >> 1;
    float dAng = PI * rcp(halfSamples);

    // Select the appropriate mip to sample based on the amount of samples. Lower sample counts will be faster at the cost of "leaking"
    float lod = min(MaxColorMip, log2(2 * PI * maxRadius * rcp(numSamples)));

    // Gather the DoF samples
    for (int ring = numSamples - 1; ring >= 0; ring --)
    {
        AccumData bgRingData, fgRingData;
        ZERO_INITIALIZE(AccumData, bgRingData);
        ZERO_INITIALIZE(AccumData, fgRingData);

        for (int i = 0; i < halfSamples; i += 1)
        {
            float r1 = GetBNDSequenceSample(posInputs.positionSS.xy, ring * numSamples + i + blueNoiseOffset, 0);
            float r2 = GetBNDSequenceSample(posInputs.positionSS.xy, ring * numSamples + i + blueNoiseOffset, 1);

#ifdef STRATIFY
            float sampleRadius = sqrt((ring + r1) * dR) * maxRadius;
#else
            float sampleRadius = sqrt(r2) * maxRadius;
#endif
            float borderRadius = sqrt((ring + 1.5) * dR) * maxRadius;

            SampleData sampleData[2];
            const float offset[2] = {0, PI };

            UNITY_UNROLL
                for (int j = 0; j < 2; j++)
                {
#ifdef STRATIFY
                    float2 sampleTC = posInputs.positionSS + sampleRadius * PointInCircle(offset[j] + (i + r2) * dAng);
#else
                    float2 sampleTC = posInputs.positionSS + sampleRadius * PointInCircle(offset[j] + r2 * PI);
#endif
                    sampleData[j].color = GetColorSample(sampleTC, lod);
                    sampleData[j].CoC = GetCoCRadius(sampleTC);
                }

            AccumulateSampleData(sampleData, centerSample, sampleRadius, borderRadius, false, bgRingData, bgAccumData);
            AccumulateSampleData(sampleData, centerSample, sampleRadius, borderRadius, true, fgRingData, fgAccumData);
        }

        AccumulateRingData(numSamples, false, bgRingData, bgAccumData);
        AccumulateRingData(numSamples, true, fgRingData, fgAccumData);
    }

    ResolveColorAndAlpha(bgAccumData.color, bgAccumData.alpha, centerSample.color);
    ResolveColorAndAlpha(fgAccumData.color, fgAccumData.alpha, centerSample.color);

    // Accumulate center sample in bg
    AccumulateCenterSample(centerSample, bgAccumData);

    // Compute the fg alpha. Needs to be normalized based on search radius.
    float maxCoC = fgAccumData.CoC / fgAccumData.color.w;
    //float maxCoC = fgAccumData.maxCoC / fgAccumData.color.w;
    float scaleFactor = (maxCoC * maxCoC) / (maxRadius * maxRadius);
    float correctSamples = scaleFactor * (numSamples * numSamples);

    // Now blend the bg and fg layes
    float fgAlpha = saturate(2 * fgAccumData.coverage / correctSamples);
    color = bgAccumData.color * (1.0 - fgAlpha) + fgAlpha * fgAccumData.color;
    alpha = bgAccumData.alpha * (1.0 - fgAlpha) + fgAlpha * fgAccumData.alpha;
}
#endif

[numthreads(GROUP_RES, GROUP_RES, 1)]
void KMain(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    PositionInputs posInputs = GetPositionInput(float2(dispatchThreadId.xy), _ScreenSize.zw, uint2(GROUP_RES, GROUP_RES));

    SampleData centerSample;
    centerSample.color = GetColorSample(posInputs.positionSS, 0);
    centerSample.CoC = GetCoCRadius(posInputs.positionSS);

    float4 cocRanges = LOAD_TEXTURE2D_X(_TileList, posInputs.positionSS / TILE_RES);
    // Note: for the far-field, we don't need to search further than than the central CoC.
    // If there is a larger CoC that overlaps the central pixel then it will have greater depth
    float maxRadius = max(2 * abs(centerSample.CoC), -cocRanges.w);

    // Detect tiles than need more samples
    int numSamples = NumRings;
#ifdef ADAPTIVE_SAMPLING
    float minRadius = min(cocRanges.x, -cocRanges.z);
    numSamples = (minRadius / maxRadius < 0.1) ? numSamples * 4 : numSamples;
#endif

    float4 outColor;
    float outAlpha;
#ifdef FAST_APPROXIMAION
    DoFGatherFast(posInputs, numSamples, maxRadius, centerSample, outColor, outAlpha);
#else
    DoFGatherRings(posInputs, numSamples, maxRadius, centerSample, outColor, outAlpha);
#endif

#ifdef ENABLE_ALPHA
    // Preserve the original value of the pixels with zero alpha.
    // The second line with the lerp+smoothstep combination avoids a hard transition in edge cases
    //outColor.xyz = outAlpha > 0 ? outColor.xyz : originalColor.xyz;
    outColor.xyz = lerp(centerSample.color.xyz, outColor.xyz, smoothstep(0, 0.01, outAlpha));
    outColor.w = outAlpha;
#endif

    _OutputTexture[COORD_TEXTURE2D_X(posInputs.positionSS)] = (CTYPE) outColor;
}
